import { sendCustomEmail, sendOrderConfirmationEmail } from "@/lib/brevo";
import { generateInvoicePDFAsBuffer } from "@/lib/invoice-generator";
import { prisma } from "@/lib/prisma";
import { sanityClient } from "@/lib/sanity";
import jwt from "jsonwebtoken";
import { NextRequest, NextResponse } from "next/server";

// Fonction pour g√©n√©rer un num√©ro de commande unique
function generateOrderNumber(): string {
	const timestamp = Date.now().toString();
	const random = Math.random().toString(36).substring(2, 8).toUpperCase();
	return `CMD-${timestamp}-${random}`;
}

// POST - Cr√©er une nouvelle commande et envoyer les emails
export async function POST(request: NextRequest) {
	try {
		// V√©rifier l'authentification avec le token JWT personnalis√©
		const token = request.cookies.get("auth-token")?.value;

		if (!token) {
			return NextResponse.json({ error: "Non autoris√©" }, { status: 401 });
		}

		// V√©rifier le token JWT
		const decoded = jwt.verify(token, process.env.NEXTAUTH_SECRET!) as any;
		const user = await prisma.user.findUnique({
			where: { id: decoded.userId },
			include: {
				profile: true,
				addresses: true,
			},
		});

		if (!user) {
			return NextResponse.json({ error: "Non autoris√©" }, { status: 401 });
		}

		const body = await request.json();
		const {
			cartItems,
			selectedAddressId,
			selectedDelivery,
			selectedPayment,
			promoCodeId,
			promoDiscount,
			subtotal,
			shippingCost,
			taxAmount,
			total,
			subscribeNewsletter,
		} = body;

		// R√©cup√©rer l'adresse de livraison
		const shippingAddress = user.addresses.find(
			(addr) => addr.id === selectedAddressId
		);
		if (!shippingAddress) {
			return NextResponse.json(
				{ error: "Adresse de livraison non trouv√©e" },
				{ status: 400 }
			);
		}

		// Cr√©er la commande
		const orderNumber = generateOrderNumber();
		const order = await prisma.order.create({
			data: {
				userId: user.id,
				orderNumber,
				status: "PENDING",
				customerEmail: user.email,
				customerName:
					`${user.profile?.firstName || ""} ${user.profile?.lastName || ""}`.trim(),
				customerPhone: user.profile?.phone,
				subtotal,
				shippingCost,
				taxAmount,
				total,
				promoCodeId,
				promoDiscount,
				paymentMethod: selectedPayment,
				paymentStatus: "PAID",
				shippingAddressId: selectedAddressId,
				billingAddressId: selectedAddressId,

				items: {
					create: cartItems.map((item: any) => ({
						productId: item.id,
						productName: item.name,
						colorName: item.color,
						sizeName: item.size,
						quantity: item.quantity,
						unitPrice: item.price,
						totalPrice: item.price * item.quantity,
					})),
				},
			},
			include: {
				items: true,
				shippingAddress: true,
				billingAddress: true,
				promoCode: true,
			},
		});

		// D√©cr√©menter le stock dans Sanity pour chaque article
		try {
			console.log("üîÑ D√©but de la d√©cr√©mentation du stock...");

			for (const item of cartItems) {
				console.log(
					`üì¶ Traitement du produit ${item.name} (${item.color}, ${item.size}) - Quantit√©: ${item.quantity}`
				);

				// R√©cup√©rer le produit d√©taill√© depuis Sanity
				// Essayer d'abord avec le nouveau syst√®me unifi√©
				let productDetail = await sanityClient.fetch(
					`
					*[_type == "productUnified" && _id == $productId][0] {
						_id,
						colors[] {
							name,
							sizes[] {
								size,
								available,
								quantity
							},
							available
						}
					}
				`,
					{ productId: item.id }
				);

				// Si pas trouv√©, essayer avec l'ancien syst√®me (pour compatibilit√©)
				if (!productDetail) {
					productDetail = await sanityClient.fetch(
						`
						*[_type == "productDetail" && product._ref == $productId][0] {
							_id,
							colors[] {
								name,
								sizes[] {
									size,
									available,
									quantity
								},
								available
							}
						}
					`,
						{ productId: item.id }
					);
				}

				if (!productDetail) {
					console.warn(`‚ö†Ô∏è Produit non trouv√© pour l'ID: ${item.id}`);
					continue;
				}

				// Trouver la couleur et la taille correspondantes
				const colorIndex = productDetail.colors.findIndex(
					(color: any) => color.name === item.color
				);

				if (colorIndex === -1) {
					console.warn(
						`‚ö†Ô∏è Couleur "${item.color}" non trouv√©e pour le produit ${item.name}`
					);
					continue;
				}

				const sizeIndex = productDetail.colors[colorIndex].sizes.findIndex(
					(size: any) => size.size === item.size
				);

				if (sizeIndex === -1) {
					console.warn(
						`‚ö†Ô∏è Taille "${item.size}" non trouv√©e pour le produit ${item.name} (${item.color})`
					);
					continue;
				}

				// V√©rifier le stock disponible
				const currentStock =
					productDetail.colors[colorIndex].sizes[sizeIndex].quantity;
				if (currentStock < item.quantity) {
					console.error(
						`‚ùå Stock insuffisant pour ${item.name} (${item.color}, ${item.size}): ${currentStock} disponible, ${item.quantity} demand√©`
					);
					return NextResponse.json(
						{
							error: `Stock insuffisant pour ${item.name} (${item.color}, ${item.size}). Stock disponible: ${currentStock}`,
						},
						{ status: 400 }
					);
				}

				// Calculer le nouveau stock
				const newQuantity = currentStock - item.quantity;
				const newAvailable = newQuantity > 0;

				// Mettre √† jour le stock dans Sanity
				const updatedColors = [...productDetail.colors];
				const updatedColor = { ...updatedColors[colorIndex] };
				const updatedSizes = [...updatedColor.sizes];
				updatedSizes[sizeIndex] = {
					...updatedSizes[sizeIndex],
					quantity: newQuantity,
					available: newAvailable,
				};
				updatedColor.sizes = updatedSizes;
				updatedColors[colorIndex] = updatedColor;

				await sanityClient
					.patch(productDetail._id)
					.set({ colors: updatedColors })
					.commit();

				console.log(
					`‚úÖ Stock mis √† jour pour ${item.name} (${item.color}, ${item.size}): ${currentStock} ‚Üí ${newQuantity}`
				);
			}

			console.log("‚úÖ D√©cr√©mentation du stock termin√©e avec succ√®s");
		} catch (error) {
			console.error("‚ùå Erreur lors de la d√©cr√©mentation du stock:", error);
			return NextResponse.json(
				{ error: "Erreur lors de la mise √† jour du stock" },
				{ status: 500 }
			);
		}

		// Vider le panier
		await prisma.cartItem.deleteMany({
			where: { userId: user.id },
		});

		// G√©rer l'inscription √† la newsletter si demand√©e
		if (subscribeNewsletter && user.email) {
			try {
				// Mettre √† jour le statut newsletter de l'utilisateur
				await prisma.user.update({
					where: { id: user.id },
					data: { newsletterSubscribed: true },
				});
				console.log(`Utilisateur ${user.email} inscrit √† la newsletter`);
			} catch (error) {
				console.error("Erreur lors de l'inscription √† la newsletter:", error);
				// Ne pas faire √©chouer la commande si l'inscription newsletter √©choue
			}
		}

		// Pr√©parer les donn√©es pour les emails
		const orderData = {
			customerName: order.customerName,
			orderNumber: order.orderNumber,
			orderDate: order.createdAt.toLocaleDateString("fr-FR"),
			totalAmount: `${order.total.toFixed(2)}‚Ç¨`,
			items: order.items.map((item) => ({
				name: item.productName,
				quantity: item.quantity,
				price: `${item.totalPrice.toFixed(2)}‚Ç¨`,
			})),
			shippingAddress: order.shippingAddress,
			deliveryMethod: selectedDelivery,
			paymentMethod: selectedPayment,
		};

		// 1. Email de confirmation au client avec facture PDF
		try {
			console.log("D√©but de g√©n√©ration de la facture PDF...");

			// G√©n√©rer la facture PDF
			const invoiceData = {
				orderNumber: order.orderNumber,
				orderDate: order.createdAt.toLocaleDateString("fr-FR"),
				customerName: order.customerName,
				customerEmail: order.customerEmail,
				customerPhone: order.customerPhone || undefined,
				shippingAddress: {
					...order.shippingAddress!,
					civility:
						order.shippingAddress?.civility === "MR"
							? "MR"
							: order.shippingAddress?.civility === "MME"
								? "MME"
								: undefined,
				},
				items: order.items.map((item) => ({
					name: item.productName,
					quantity: item.quantity,
					unitPrice: item.unitPrice,
					totalPrice: item.totalPrice,
					colorName: item.colorName || undefined,
					sizeName: item.sizeName || undefined,
				})),
				subtotal: order.subtotal,
				taxAmount: order.taxAmount,
				shippingCost: order.shippingCost,
				promoDiscount: order.promoDiscount,
				total: order.total,
				paymentMethod: selectedPayment,
			};

			console.log("G√©n√©ration du PDF...");
			const pdfBuffer = generateInvoicePDFAsBuffer(invoiceData);
			console.log("PDF g√©n√©r√© avec succ√®s");

			console.log("Envoi de l'email de confirmation...");
			// Envoyer l'email avec la facture PDF en pi√®ce jointe
			await sendOrderConfirmationEmail(user.email, orderData, pdfBuffer);
			console.log("Email de confirmation avec facture PDF envoy√© au client");
		} catch (error) {
			console.error(
				"Erreur lors de l'envoi de l'email de confirmation:",
				error
			);
			// Ne pas faire √©chouer la commande si l'email √©choue
		}

		// 2. Email au vendeur avec les d√©tails de la commande
		try {
			const vendorEmailData = {
				to: "contact@ladyhaya-wear.fr",
				subject: `Nouvelle commande #${order.orderNumber} - √Ä pr√©parer`,
				htmlContent: `
          <html>
            <body>
              <h1>Nouvelle commande re√ßue !</h1>
              <h2>Commande #${order.orderNumber}</h2>
              
              <h3>Informations client :</h3>
              <p><strong>Nom :</strong> ${order.customerName}</p>
              <p><strong>Email :</strong> ${order.customerEmail}</p>
              <p><strong>T√©l√©phone :</strong> ${order.customerPhone || "Non renseign√©"}</p>
              
              <h3>Adresse de livraison :</h3>
              <p>${order.shippingAddress?.civility === "MR" ? "M." : "Mme"} ${order.shippingAddress?.firstName} ${order.shippingAddress?.lastName}</p>
              <p>${order.shippingAddress?.street}</p>
              <p>${order.shippingAddress?.zipCode} ${order.shippingAddress?.city}</p>
              <p>${order.shippingAddress?.country}</p>
              
              <h3>Mode de livraison :</h3>
              <p>${
								selectedDelivery === "domicile"
									? "√Ä domicile (Colissimo)"
									: selectedDelivery === "relay"
										? "Point relais (Mondial Relay)"
										: "Livraison express (Chronopost)"
							}</p>
              
              <h3>Articles √† pr√©parer :</h3>
              <table style="border-collapse: collapse; width: 100%; margin: 20px 0;">
                <thead>
                  <tr style="background-color: #f8f9fa;">
                    <th style="border: 1px solid #ddd; padding: 8px; text-align: left;">Produit</th>
                    <th style="border: 1px solid #ddd; padding: 8px; text-align: center;">Couleur</th>
                    <th style="border: 1px solid #ddd; padding: 8px; text-align: center;">Taille</th>
                    <th style="border: 1px solid #ddd; padding: 8px; text-align: center;">Quantit√©</th>
                    <th style="border: 1px solid #ddd; padding: 8px; text-align: right;">Prix unitaire</th>
                    <th style="border: 1px solid #ddd; padding: 8px; text-align: right;">Total</th>
                  </tr>
                </thead>
                <tbody>
                  ${order.items
										.map(
											(item) => `
                    <tr>
                      <td style="border: 1px solid #ddd; padding: 8px;">${item.productName}</td>
                      <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${item.colorName || "-"}</td>
                      <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${item.sizeName || "-"}</td>
                      <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${item.quantity}</td>
                      <td style="border: 1px solid #ddd; padding: 8px; text-align: right;">${item.unitPrice.toFixed(2)}‚Ç¨</td>
                      <td style="border: 1px solid #ddd; padding: 8px; text-align: right;">${item.totalPrice.toFixed(2)}‚Ç¨</td>
                    </tr>
                  `
										)
										.join("")}
                </tbody>
              </table>
              
              <h3>R√©capitulatif financier :</h3>
              <p><strong>Sous-total HT :</strong> ${order.subtotal.toFixed(2)}‚Ç¨</p>
              <p><strong>TVA (20%) :</strong> ${order.taxAmount.toFixed(2)}‚Ç¨</p>
              <p><strong>Frais de livraison :</strong> ${order.shippingCost.toFixed(2)}‚Ç¨</p>
              ${order.promoDiscount > 0 ? `<p><strong>R√©duction promo :</strong> -${order.promoDiscount.toFixed(2)}‚Ç¨</p>` : ""}
              <p><strong>Total TTC :</strong> <strong style="color: #d9c4b5; font-size: 1.2em;">${order.total.toFixed(2)}‚Ç¨</strong></p>
              
              <h3>Mode de paiement :</h3>
              <p>${selectedPayment === "cb" ? "Carte bancaire" : "PayPal"}</p>
              
              <hr style="margin: 30px 0;">
              <p><em>Cette commande a √©t√© automatiquement confirm√©e et pay√©e.</em></p>
              <p><em>Merci de pr√©parer cette commande dans les plus brefs d√©lais.</em></p>
            </body>
          </html>
        `,
			};

			await sendCustomEmail(vendorEmailData);
			console.log("Email de notification envoy√© au vendeur");
		} catch (error) {
			console.error("Erreur lors de l'envoi de l'email au vendeur:", error);
		}

		return NextResponse.json({
			success: true,
			orderId: order.id,
			orderNumber: order.orderNumber,
		});
	} catch (error) {
		console.error("Erreur lors de la cr√©ation de la commande:", error);

		// Log d√©taill√© de l'erreur pour le debug
		if (error instanceof Error) {
			console.error("Message d'erreur:", error.message);
			console.error("Stack trace:", error.stack);
		}

		return NextResponse.json(
			{
				error: "Erreur lors de la cr√©ation de la commande",
				details: error instanceof Error ? error.message : "Erreur inconnue",
			},
			{ status: 500 }
		);
	}
}

// GET - R√©cup√©rer les commandes de l'utilisateur
export async function GET(request: NextRequest) {
	try {
		// V√©rifier l'authentification avec le token JWT personnalis√©
		const token = request.cookies.get("auth-token")?.value;

		if (!token) {
			return NextResponse.json({ error: "Non autoris√©" }, { status: 401 });
		}

		// V√©rifier le token JWT
		const decoded = jwt.verify(token, process.env.NEXTAUTH_SECRET!) as any;
		const user = await prisma.user.findUnique({
			where: { id: decoded.userId },
		});

		if (!user) {
			return NextResponse.json(
				{ error: "Utilisateur non trouv√©" },
				{ status: 404 }
			);
		}

		const orders = await prisma.order.findMany({
			where: { userId: user.id },
			include: {
				items: true,
				shippingAddress: true,
				billingAddress: true,
				promoCode: true,
			},
			orderBy: { createdAt: "desc" },
		});

		return NextResponse.json({ orders });
	} catch (error) {
		console.error("Erreur lors de la r√©cup√©ration des commandes:", error);
		return NextResponse.json(
			{ error: "Erreur lors de la r√©cup√©ration des commandes" },
			{ status: 500 }
		);
	}
}
